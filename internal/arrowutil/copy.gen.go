// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: copy.gen.go.tmpl

package arrowutil

import (
	"fmt"

	"github.com/apache/arrow/go/arrow/array"
)

func Copy(b array.Builder, arr array.Interface) {
	switch arr := arr.(type) {

	case *array.Int64:
		CopyInt64s(b.(*array.Int64Builder), arr)

	case *array.Uint64:
		CopyUint64s(b.(*array.Uint64Builder), arr)

	case *array.Float64:
		CopyFloat64s(b.(*array.Float64Builder), arr)

	case *array.Boolean:
		CopyBooleans(b.(*array.BooleanBuilder), arr)

	case *array.Binary:
		CopyStrings(b.(*array.BinaryBuilder), arr)

	default:
		panic(fmt.Errorf("unsupported array data type: %s", arr.DataType()))
	}
}

func CopyInt64s(b *array.Int64Builder, arr *array.Int64) {
	b.Reserve(arr.Len())

	for i, sz := 0, arr.Len(); i < sz; i++ {
		if arr.IsValid(i) {
			b.Append(arr.Value(i))
		} else {
			b.AppendNull()
		}
	}
}

func CopyUint64s(b *array.Uint64Builder, arr *array.Uint64) {
	b.Reserve(arr.Len())

	for i, sz := 0, arr.Len(); i < sz; i++ {
		if arr.IsValid(i) {
			b.Append(arr.Value(i))
		} else {
			b.AppendNull()
		}
	}
}

func CopyFloat64s(b *array.Float64Builder, arr *array.Float64) {
	b.Reserve(arr.Len())

	for i, sz := 0, arr.Len(); i < sz; i++ {
		if arr.IsValid(i) {
			b.Append(arr.Value(i))
		} else {
			b.AppendNull()
		}
	}
}

func CopyBooleans(b *array.BooleanBuilder, arr *array.Boolean) {
	b.Reserve(arr.Len())

	for i, sz := 0, arr.Len(); i < sz; i++ {
		if arr.IsValid(i) {
			b.Append(arr.Value(i))
		} else {
			b.AppendNull()
		}
	}
}

func CopyStrings(b *array.BinaryBuilder, arr *array.Binary) {
	b.Reserve(arr.Len())

	{
		var datasz int
		for i, sz := 0, arr.Len(); i < sz; i++ {
			if arr.IsValid(i) {
				datasz += arr.ValueLen(i)
			}
		}
		b.ReserveData(datasz)
	}

	for i, sz := 0, arr.Len(); i < sz; i++ {
		if arr.IsValid(i) {
			b.AppendString(arr.ValueString(i))
		} else {
			b.AppendNull()
		}
	}
}
